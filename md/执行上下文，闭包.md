# 执行上下文
- 当前代码的执行环境

## 分类
1. 全局上下文
	- 打开浏览器后，在代码运行之前就存在的
2. 局部上下文
	- 当一个函数被调用时，会产生一个函数体内的执行环境，这个就执行环境就叫做局部上下文。当函数执行完成后，当前局部上下文就会被销毁
	- 调用一次就会产生一个局部上下文，即使是调用自己
	- 和作用域的区别:作用域是在定义的时候产生，而执行上下文是在执行的时候产生
	- 执行上下文生命周期
		1. 执行上下文创建阶段  
			1. 创建变量对象（VO）  
				 - **变量对象(variable object),简称VO**：用来记录在当前作用域内能够访问到的变量（参数、声明式函数、变量）。
				- 变量对象的内部数据不能操作，但是当代码进入执行阶段后，变量对象会变成**活动对象(artive object)AO**，里面的数据就可以操作了。  
			2. 建立作用域链（跟作用域没有关系）
				- 由一系列变量对象组成，保证了执行上下文对变量的有序访问
				- **作用域链是根据声明时来确定的，不是调用**

						var food="肉"
						function other(){  
						    var food="巧克力"
						    eat()
						}
						var eat=function(){
						    console.log(food)
						}
						other() //输出 肉，因为声明时父级是全局
			3. 确定this的指向
		2. 代码执行阶段
		3. 执行上下文销毁阶段


3. eval()上下文

#闭包
- 函数要形成闭包要满足以下几个条件：
	1. 访问自身所在作用域
	2. 函数有嵌套
	3. 在自身所在作用域之外调用
- 闭包的两种表现形式
	1. 函数作为返回值
	2. 函数作为参数
- 缺点：滥用闭包会导致内存的浪费
- 优点：
	1. 扩大了局部变量的作用域，使外部能够访问内部变量。
	2. 避免了变量污染（变量冲突）。