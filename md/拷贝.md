
# 拷贝
### 浅拷贝（针对引用数据类型）
  - 拷贝后的新对象和原对象指向的同一个引用地址，改变一个会影响另一个
	
### 深拷贝（针对引用数据类型）
  - 拷贝前和拷贝后的内容相同，但是指向不同的地址，改变其中一个不会影响另外一个
##### 方法
  - 手动复制

		let person = {
		    name: 'lisi',
		    age:20
		}
		let newPerson={ name:person.name, age:person.age}
		person.age=30
		console.log(person) //{ name: 'lisi', age: 30 }
		console.log(newPerson)//{ name:'lisi',age: 20 }

  - **Object.assign(目标对象，源对象)**：拷贝对象，把源对象拷贝进目标对象，返回新对象，源对象可以是多个，有一个缺陷，就是只生成了一个新对象，如果引用数据类型里面还有引用数据就会拷贝地址，那么里面那层的引用数据相互之间会影响
		
		let person = {
		    name: 'lisi',
		    age:20
		}
		let newPerson=Object.assign({},person,{pwd:123})
		person.age=30
		console.log(person) //{ name: 'lisi', age: 30 }
		console.log(newPerson)//{name:'lisi',age:20,pwd: 123 }

	受影响情况

		let person = {
		    name: 'lisi',
		    age:{
		        num:20
		    }
		}
		let newPerson=Object.assign({},person)
		person.age.num=30
		console.log(person) //{name:'lisi',age:{ num: 30 }}
		console.log(newPerson)//{name:'lisi',age:{num: 30}}
			

- 转换为字符串
	 
	  - **JSON.stringify()**：转换为json字符串  
	  - **JSON.parse()**:转换为json对象

  	先把对象转换为Json字符串，然后再转换为JSON对象赋值给新的对象，里面的东西就拷贝了一遍，而且地址也换新的了

		let person={
		    name:'lisi',
		    age:{
		        num:20
		    }
		}
		let str=JSON.stringify(person) //转换为字符串给str
		let newPerson=JSON.parse(str)  //把str又转换为对象给新对象
		person.age.num=30;  //修改旧对象，新对象不收影响
		console.log(person) //{name:'lisi',age:{num: 30}}
		console.log(newPerson)//{name:'lisi',age:{num: 20 } }

 - 递归方法
		  
		老师讲的
		let person = {
		    name: 'lisi',
		    age: {
		        num: 20
		    }
		}
		function deepClone(data){
		    if(typeof data =='object'){
		        let newData={};
		        for(let k in data){
		            newData[k]=deepClone(data[k])
		        }
		        return newData;
		    }
		    return data;
		}
		let newPerson = repeat(person)
		person.age.num = 25
		console.log(person)
		console.log(newPerson)
			
	这个函数自己想的，效果一样，不知道有没有bug

		function repeat(data) {
		    let newData = {}
		    for (let k in data) {
		        if (typeof data[k] == 'object') {
		            newData[k] = repeat(data[k])
		        } else {
		            newData[k] = data[k]
		        }
		    }
		    return newData
		}